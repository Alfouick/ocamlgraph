2009-08-04

WEEK 1

We want to visualize clustered graphs (Frama-C services), and allow
the developper to inherit the widget and add events to nodes
(example : dependency graph in Frama-C, click a on a node to
get to the code).

ARCHITECTURE: Frama-C <-> OCamlGraph <-> Lablgtk2

Day 1
Setting up the computer?
Reading Gtree documentation to get acquainted with the
Model-View-Controller architecture.

Day 2 and 3
Reading lablgtk documentation, discovering GUI programming.
Reading the current implementation (view_graph), which has several
limitations :
 - slow zoom
 - slow loading (?)
 - limited interactivity (no interactivity with edges)
 - objects stacked on the png
 - difficult to tailor to one's needs
 - no architecture (no MVC)
 - dependent on OCamlGraph (cannot be integrated in lablgtk2)

ARCHITECTURE:
  dot -> annotated dot -> (graph, ((shape, position), png)) -> canvas

PLAN
- Model and the View.
  - Model : graph, layout informations
  - View : view_nodes, view_edges class, not sure about the content
- Parse more layout informations
- Get rid of png (slows down scrolling and zooming)

First modifications on old implementation, just print ellipses and text
labels, no edges. Some refactoring.
Reading OCamlGraph code too, functors and dot parser.
Learning Lablgtk2 and Gnome Canvas.

Modifications on the parser to get the graph bounding box
(previously got from the png file), first succesfull display.

WEEK 2

First implementation of the View class.
- Keeps a reference to a canvas
- Creates gtk objects (ellipses) corresponding to nodes
- Places them on the canvas
- Keeps refereces to these objects

Classes View_node and View_edge
View_node : gtk shape (ellipse or rect), gtk text
View_edge : gtk polyline

First visualisations, using simple file from Graphviz doc.
Parses edges as polylines from pos attributes in dot files.
Fast and easy.

But polyline edges not graphically satisfying
(no curves, just straight lines).
Have to handle Bezier curves.
According to Graphviz doc, possible with xdot files
(which are dot files with much more graphical information).

Modify OcamlGraph dot parser to get _draw_ attribute.
Writes code to get control points from the _draw_ attribute in xdot files.
No real parser though, just splits the line and get the B attribute.

Now have control points, but does not understand how to draw Bezier curves
 on the Gnome Canvas.
Canvas curves appear to have only 3 control points
(whereas 4 or more in dot).

After searching, discovers the curves are b-spline curves,
which gnome canvas handles well.
Algorithm is:
  fix starting points
  repeat curve 3 next control points until no control points left

Turns out inheriting from GnomeCanvas object is possible,
dig into library source code with internship master.
Technical details: Here be dragons.

Loading big graphs take time.
After placing timers and investigating with internship master,
turns out antialiased text slows down everything.
Each text element takes 1/100 second to load, which means
5 sec. to load 500 nodes.

Thoughts about making loading faster. Perhaps load text objects
somehow lazily, only that is when user can see it (in current window,
when close enough).

Apparently problem does not exist with Gnome Cairo,
plus hardware acceleration and smooth zooming.
Should we switch ? Decide to continue with Canvas for the moment,
once loaded, scrolling is fast and zoom acceptable.

Now that rendering is satisfying, implementing interface with file chooser.
Decide to try adding various events to canvas :
 - Node selection (text becomes bold, lines wider) with left click
 - Node highlighting (text and lines become red, edges starting from node
   red too, easy to spot successors) when mouse comes over
 - Multi-node selection (when 2 nodes connected by edge selected,
   this edge is bolder too)
 - Right click menu on nodes : select successors, select predecessors
 - Double clicking on node to center canvas on it

WEEK 3

Realizing widget still lacks layout and graphical information.
Decide to parse whole _draw_ attributes in xdot.
Write little recursive descent parser, returns
operation list (draw polygon, draw ellipse, pen color to red, ...).

Integration of new drawing informations with GraphView module.

Now nodes can have several shapes, several text elements.
Changes to View node class :
- Algebraic shape data type
- Shape list (not just one)
- Text list
- Connect functions to connect callbacks to shapes and texts

Rendering now beautiful : complex polygon shapes rendered,
all colors supported.
Test with various files from graphviz site (ex: crazy.dot)

REPORT

  FEATURES
  - All colors and shapes for nodes and edges are now supported.
  - Fast loading if not too much text.
  - XDot file now read through a pipe (no writing on the disk).

  LIMITATIONS

  - VIEW
    - Dot styles are not taken into account (dotted lines for example).
    - Text size does not change with the zoom.
    - Dezooming shifts the text up.
    - Zooming still a bit slow

  - MODEL
  - Still depends on OCamlGraph for :
    - storing vertices and edges
    - getting successors or predecessors
    - parsing dot files
    - generating dot files

TODO: keep object properties when selection

Now diving into OCamlGraph to read its graph implementation.
Plan: mimick it into virtual class GraphModel and
write the functor mapping OCamlGraph to GraphModel.

Abstract class written.

Added support for fonts and font sizes in graphs.
Problems with font sizes though, seem too big.
Size kept at 10 points for the moment.

Text now scales with zoom.

Nodes and edges are now subclasses of a common class : a container of
shapes and texts that can be selected or highlighted.

Tuesday

When generating dot and then xdot from graph model, would like
not to build a new graph model from XDot, but updates graph model
with layout.
Thus added 4 methods in abstract class :
get_node_layout, set_node_layout, get_edge_layout, set_edge_layout

Back on the model :
Writing abstract class for models is easy.
Writing functor accepting OCamlGraph module and returning concrete class
easy too (current implementation already does it).
No OcamlGraph dependency anymore, fully customisable !
Problem though : cannot expect developper to roll out his own graph
implementation to use my widget. More likely to use default simple
implementation and switching to OCamlGraph model or more specialized one
in the future.

So, implementing default concrete class for the moment.
More work than I previously thought.
The aforementionned 4 methods are bitches to implement : to update
layout in node, have to get node from label in xdot.
How to do it ? Label hash table ?

Decided to go the hash-table-from-label-to-node-or-edge way.
