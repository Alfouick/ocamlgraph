%-----------------------------------------------------------------------------
%
%               Template for LaTeX Class/Style File
%
% Name:         sigplanconf-template.tex
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[]{tfp05symp}

\usepackage{amsmath}
\usepackage{url}
\usepackage{xspace}
\usepackage{alltt}
\usepackage{verbatim,rotating}
%\usepackage{color}
%\usepackage[dvips]{epsfig}
\usepackage{graphicx}

\newcommand{\ocamlgraph}{\textsc{Ocamlgraph}\xspace}
\newcommand{\ocaml}{\textsc{Ocaml}\xspace}
\newcommand{\fl}{\ensuremath{\rightarrow}}

\begin{document}

%\conferenceinfo{GPCE '06}{October 22--26 2006, Portland, Oregon.} 
%\copyrightyear{2006} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{}        % These are ignored unless
%\preprintfooter{}   % 'preprint' option specified.

\title{Designing a Generic Graph Library \\ using ML Functors}
%\subtitle{}

%\authorinfo{Submitted for blind review}{}{}
\author{S. Conchon\and J.-C. Filli\^atre\and J. Signoles}
\institute{LRI Universit\'e Paris Sud 91405 Orsay France \\
  \texttt{\{conchon,filliatr\}@lri.fr Julien.Signoles@cea.fr}}

\maketitle

\begin{abstract}
  This article details the design and implementation of \ocamlgraph, a
  generic graph library for the programming language \ocaml. This
  library features a large set of graph data structures---directed or
  undirected, with or without labels on vertices and edges, as persistent
  or mutable data structures, etc.---and a large set of graph
  algorithms written independently of the graph data structure. Such a
  genericity is obtained through a massive use of \ocaml module system
  and of its functions, the so-called \emph{functors}.
\end{abstract}

%\category{D.2}{Software Engineering}{Software Architectures; Design;
%  Reusable Software}

%\terms
%term1, term2

%\keywords
%Graph library, Generic programming, Functors

\section{Introduction}

Finding a graph library for one's favorite programming language is
usually easy. But using the provided algorithms on one's
own graph data structure or building undirected persistent graphs with
vertices and edges labeled with something else than integers is
likely to be more difficult. Figure~\ref{comparison:tab} quickly
compares several graph libraries according to the following criteria: 
the number of graph data structures; the purely applicative or
imperative nature of the structures; and the ability to apply the
provided algorithms to a user graph data structure.
As we can notice, none of these libraries gives full satisfaction.
This article introduces
\ocamlgraph\footnote{\url{http://www.lri.fr/~filliatr/ocamlgraph/}}, a
highly generic graph library for the programming language
\ocaml~\cite{ObjectiveCaml}, which intends to fulfill all 
these criteria.

% Beside the mere presentation of this
% library, this article demonstrates how \ocaml has been used to
\ocamlgraph\ introduces genericity at two levels. First, \ocamlgraph
does not provide a single data structure for graphs but many of them,
enumerating all possible variations---directed or undirected graphs,
persistent or mutable data structures, user-defined labels on vertices
or edges, etc.---under a common interface.
Second, \ocamlgraph provides a large set of graph algorithms that are
written independently of the underlying graph data structure. Then
they can be applied on the data structures provided by \ocamlgraph
itself but also on user-defined data structures as soon as they
implement a minimal set of functionalities.

Without proper parameterization, such a large set of variants may
easily result into an unmanageable code. We avoid this pitfall
using the \ocaml module system~\cite{leroy00}, which
appears to be the tool of choice to do such meta-programming. 
The genericity of \ocamlgraph is indeed achieved through a massive use
of \ocaml functors. In the first case, they are used to avoid code
duplication between the many variations of graph data structures,
which is mandatory here seen the high number of similar but all
different implementations. In the second case, they are used to write
the graph algorithms independently of the underlying graph data
structure, with as much genericity as possible but also with an
efficiency concern in mind. 

% TODO
This article is organized as follows. Section~\ref{systememodules}
briefly introduces the \ocaml module system. Then
Section~\ref{structuresdedonnees} exposes the design of the common
interface for all graph data structures and explains how the code is
shared among the various implementations. Section~\ref{algos}
describes the algorithms provided in \ocamlgraph and how the
genericity with respect to the graph data structure is obtained.
Section~\ref{exemples} illustrates the use of \ocamlgraph\ on two
typical situations.  Finally Section~\ref{bench} presents some
benchmarks and Section~\ref{comparaison} compares \ocamlgraph with
several existing graph libraries.

% \section{Related Work}
% \label{comparaison}

% This section details the features of several other graph libraries, in
% order to make a comparison with \ocamlgraph. Our list is not
% exhaustive and only focuses on programming languages where some kind
% of generic programming is possible. Figure~\ref{comparison:tab}
% summarizes our comparison criteria which are mainly based on the
% genericity of the data structures and algorithms proposed by some
% other libraries.

\begin{figure*}[t]
\newcommand{\present}{\large\boldmath $\surd$}
\newcommand{\absent}{\large\boldmath $\oslash$}

  \centering
  \begin{tabular}{|l||c|c|c|c|c|}
    \hline
     &          & graph data & persistent / & generic    \\
     & language & structures & imperative   & algorithms \\\hline\hline
     LEDA & C++    & 2  & I & \absent   \\\hline
     GTL & C++     & 1  & I & \absent   \\\hline
     MLRisc & SML  & 1  & I & \absent   \\\hline
     FGL & Haskell & 1  & P & \present  \\\hline
     Baire & \ocaml & 8 &P/I& ---      \\\hline
     JDSL & Java   & 1  & I & \present  \\\hline
     BGL & C++     & 1  & I & \present  \\\hline
%     \ocamlgraph& \ocaml &P/I& \present & 19 \\\hline
  \end{tabular}
  \medskip
  \caption{Comparison with other graph libraries}
  \label{comparison:tab}
\end{figure*}

\section{Motivating Example and Design Overview}

As a running example, we consider a Sudoku solver based on graph
coloring.  The idea is to represent the Sudoku grid as an undirected
graph with $9\times 9$ vertices, each vertex being connected to the
other vertices on the same row, column or $3\times 3$ group. Then
solving the Sudoku is equivalent to 9-coloring this graph.
What we should expect from a good graph library is thus:
\begin{enumerate}
\item the ability to easily build an undirected graph where each
  vertex is labeled with a pair of integers (the cell coordinates);
\item an efficient graph coloring algorithm that can be applied to the
  above data structure. 
\end{enumerate}
If a graph library is providing only directed graphs or only
unlabeled vertices, one has to adapt to the existing data structure.
Generally speaking, the user may want
to choose any combination of the following features:
\begin{itemize}
\item \emph{directed} or \emph{undirected} graphs;
\item \emph{labeled} or \emph{unlabeled} vertices and edges;
\item \emph{types} for the labels, when any;
\item \emph{persistent} or \emph{imperative} data structure;
\end{itemize}
The strong point in \ocamlgraph is to provide \emph{all} possible
combinations, as ML modules sharing a common signature \texttt{G}.
Then algorithms are provided as ML functors whose arguments must have
signatures compatible with \texttt{G}.

\section{Implementation}

We now describe the implementation of
\ocamlgraph. First Section~\ref{interface} describes the common
signature for all graph data structures.
Then Section~\ref{structuresdedonnees} details the various graph
implementations. Finally Section~\ref{algos} explains how
generic algorithms are provided.

\subsection{Common Signature}\label{interface}

The common signature for all graph data structures includes an
abstract type \texttt{t} for the graphs, two modules \texttt{V} and
\texttt{E} for vertices and edges respectively, and all the
observers. The latter include several functions to iterate over
vertices and edges, which are massively used in graph algorithms. 
The common signature thus looks like:
\begin{verbatim}
module type G = sig
  type t
  module V : sig type t ... end
  module E : sig type t ... end
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  ...
end
\end{verbatim}
Then we distinguish two signatures for persistent and imperative
graphs, \texttt{P} and \texttt{I} respectively, since the modifiers do
not have the same types:
\begin{verbatim}
module type P = sig
  include G
  val empty : t
  val add_vertex : t -> vertex -> t
  val add_edge : t -> vertex -> vertex -> t
  ...
end
module type I = sig
  include G
  val create : unit -> t
  val add_vertex : t -> vertex -> unit
  val add_edge : t -> vertex -> vertex -> unit
  ...
end
\end{verbatim}

\subsection{Graph Data Structures}\label{structuresdedonnees}

\ocamlgraph provides 16 graph data structures, which are all the
possible combinations of the following 4 criteria:
\begin{itemize}
\item \emph{directed} or \emph{undirected} graphs;
\item \emph{labeled} or \emph{unlabeled} edges;
\item \emph{persistent} or \emph{imperative} data structure;
\item \emph{concrete} or \emph{abstract} type for the vertices.
\end{itemize}
The last point requires some explanation: vertices are always labeled
but the user may choose between \emph{concrete} vertices where vertices and
their values are identical and \emph{abstract} vertices where the
values are hidden inside an abstract data type for vertices. The
former allows a more immediate use of the data structure and the
latter allows a more efficient implementation.

Each graph data structure is provided as a
functor, parameterized by user types for vertex labels and possibly edge
labels. These 16 
functors are displayed Figure~\ref{fig:interfaces} as square boxes
mapping signatures of input modules to signatures of output modules.
\begin{figure*}
  \centering
  %\includegraphics[width=\textwidth]{interface.pdf}    
  \includegraphics[width=\textwidth]{interface.eps} 
  \caption{\ocamlgraph's data structures components}\label{fig:interfaces}
\end{figure*}
Three other implementations complete the set of graph data structures,
namely \texttt{ConcreteBidirectional} for graphs with an efficient
access to predecessors, and
\texttt{Matrix.}(\texttt{Graph}, \texttt{Digraph}) for graphs
implemented as adjacency matrices.
Putting all together, the code for the 19 graph data structures amounts
to 1059 lines. This is clearly small enough to be easily
maintained. In Section~\ref{bench} we will show that this code is also
quite efficient.

The graph data structure for our Sudoku solver is thus simply obtained as
\begin{verbatim}
module G = Imperative.Graph.Abstract
             (struct type t = int * int end) 
\end{verbatim}
that is an imperative undirected graph with abstract vertices labeled
with pairs of inteers and unlabeled edges.

\section{Algorithms}\label{algos}

This section introduces the second use of functors in \ocamlgraph: the
generic programming of graph algorithms.

\subsection{Generic Programming}

As demonstrated in the previous section, our library provides many
graph data structures. Therefore, it is necessary to figure out how to
implement graph algorithms without duplicating code for each data
structure. Exactly as functors helped factorizing code in the previous
section, they provide a nice way to code the algorithms in a generic
way.

The basic idea is to code an algorithm without worrying about the
underlying graph data structure but focusing only on the required
operations over this data structure. Then the algorithm is naturally a
functor parameterized by these operations. Such operations usually
make a subset of the operations provided by \ocamlgraph's own data
structures, but some algorithms may require specific operations,
independent of the graph data structure. In such a case, they will be
provided as an additional functor parameter.

Such a ``functorization'' of algorithms has two benefits: first, it
allows to quickly add a new algorithm to the library, without code
duplication for all data structures; second, it allows the user to
apply an algorithm on its own graph data structure, which is an
original feature of \ocamlgraph\ w.r.t. other graph libraries.

\begin{comment}
\subsection{Example: Flow Algorithms}
\label{algos-flot}

We illustrate the generic implementation of algorithms in \ocamlgraph\
through two algorithms to compute the maximal flow of a
network\footnote{that is a directed graph with two distinguished
  vertices, a source and a terminal.}, namely the
Ford-Fulkerson~\cite{FF} and Goldberg~\cite{Goldberg} algorithms.
They appear as two functors with the following signatures:
\begin{alltt}
module Ford_Fulkerson 
  (G: G_FORD_FULKERSON)
  (F: FLOW with type label = G.E.label) :
sig
  val maxflow : 
    G.t -> G.V.t -> G.V.t -> (G.E.t -> F.t) * F.t
end

module Goldberg
  (G: G_GOLDBERG)
  (F: FLOW with type label = G.E.label) : 
sig
  val maxflow : 
    G.t -> G.V.t -> G.V.t -> (G.E.t -> F.t) * F.t
end
\end{alltt}
Each functor body implements a \texttt{maxflow} function expecting a
network, a source vertex and a terminal vertex, and returning a
pair \texttt{(f, delta)} where \texttt{f} maps each edge of the
network to its new flow and where \texttt{delta} is the difference
between the computed maximal flow and the initial flow of the network.

The signature of the first parameter \texttt{G} of these two functors
describes the minimal set of graph operations required for the
implementation of \texttt{maxflow}. Since the two algorithms are
different, the signatures \texttt{G\_FORD\_FULKERSON} and
\texttt{G\_GOLDBERG} are thus different. For instance, Goldberg
algorithm requires to iterates over the vertices and edges of the graph,
whereas Ford-Fulkerson algorithm only requires to iterate over the
successors and predecessors of a vertex. This appears clearly in the
signatures:
\begin{alltt}
module type G_GOLDBERG = sig
  type t
  module V : sig type t (* ... *) end
  module E : sig type t (* ... *) end
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_edges_e : (E.t -> unit) -> t -> unit
  (* ... *)
end

module type G_FORD_FULKERSON = sig
  type t
  module V : sig type t (* ... *) end
  module E : sig type t (* ... *) end
  val iter_succ_e : 
    (E.t -> unit) -> t -> V.t -> unit
  val iter_pred_e : 
    (E.t -> unit) -> t -> V.t -> unit
end
\end{alltt}

The signature of the second parameter \texttt{F} is common to both
algorithms. It gathers all operations to manipulate the labels on edges
as flows:
\begin{alltt}
module type FLOW = sig
  type label \hfill(* type of edges labels *)
  type t \hfill(* type of flow *)
  val flow : label -> t \hfill(* initial flow *)
  val max_capacity : label -> t \hfill(* max. capacity *)
  val min_capacity : label -> t \hfill(* min. capacity *)
  val add : t -> t -> t \hfill(* addition *)
  val sub : t -> t -> t \hfill(* subtraction *)
  val zero : t \hfill (* neutral element *)
  val compare : t -> t -> int \hfill(* comparison *)
end
\end{alltt}
This signature \texttt{FLOW} is easily implemented, whatever the
data type is. For instance, a possible implementation for a graph where
edges are labeled with integers representing the maximal capacities of
edges and with an initial empty flow would be the following:
\begin{alltt}
module Flow = struct
  type label = int
  type t = int
  let max_capacity x = x
  let min_capacity _ = 0
  let flow _ = 0
  let add = (+)
  let sub = (-)
  let compare = compare
  let zero = 0
end
\end{alltt}
\end{comment}

\subsection{Example: Graph Traversal}
\label{dfs}

We give here another example of generic programming with the classical
depth-first and breadth-first traversals. To traverse a graph, we
need very few operations. Basically, we need to iterate over the
successors of a vertex. To reach all the connected components of the
graph, we also need to iterate over all vertices. Finally, we have to
mark the visited vertices. Regarding this last point, the simplest way is
to use a hash table (when no particular assumption can be made about
the graph data structure). To build such a hash table, we simply need
the type of vertices to be equipped with suitable \texttt{hash} and
\texttt{equal} functions. Therefore, the minimal expected signature
for traversal algorithms is the following:
\begin{alltt}
module type G = sig
  type t
  module V : sig type t 
                 val hash : t -> int 
                 val equal : t -> t -> bool end
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
end
\end{alltt}
Then traversal algorithms can be provided with a signature like:
\begin{alltt}
module Dfs(G : G) : 
  sig val iter : (G.V.t -> unit) -> G.t -> unit end
\end{alltt}
In practice, however, several variants of each traversal are provided:
traversal of a single connected component, application of the visitor
function after the successors are visited (instead of before),
etc. The depth-first traversal functor also provides a cycle detection
function. Finally, there is a functor specialized for graphs equipped
with marks (see signature \texttt{IM} in Section~\ref{interfaces}),
since such marks can be directly used to mark the visited vertices (and
for further use by the library client).

Graph traversals are also provided as \emph{cursors},
i.e. step-by-step iterators similar to those used in object-oriented
programming~\cite{coplien92} (e.g. the \textsc{Java}
\texttt{Iterator} interface).
Such a cursor is given the following signature:
\begin{alltt}
module Dfs(G : G) : sig
  type iterator
  val start : G.t -> iterator
  val step : iterator -> iterator
  val get : iterator -> G.V.t
end 
\end{alltt}
The abstract type \texttt{iterator} represents a state of the
iterator, or equivalently a position in the ongoing iteration. We get
the starting point with the \texttt{start} function. Then we can
advance in the iteration using the \texttt{step} function and we can
obtain the currently visited vertex using the \texttt{get} function.
These two functions raise the \texttt{Exit} exception whenever the
iteration is over. There is a huge difference w.r.t. usual cursors in
imperative programming, however: the data type \texttt{iterator} is
persistent. It means that the iterator is not modified when the step
function is called, but a new iterator is returned instead. Therefore
it is easy to use such iterators in \emph{backtracking} algorithms
that may need to come back to previous positions in an
iteration~\cite{filliatre06}. 

Here is for instance a simple implementation of a $k$-coloring
algorithm based on a breadth-first traversal implemented as a
persistent cursor. We assume that the graph \texttt{g} contains
integer marks that we use to indicate the color (the value 0 meaning
that there is no assigned color yet).
\begin{alltt}
let coloring g k =
  Mark.clear g;
  let try_color v i =
    iter_succ 
      (fun w -> 
        if Mark.get w = i then raise NoColor) 
      g v;
    Mark.set v i
  in
  let rec iterate iter =
    let v = Bfs.get iter in
    for i = 1 to k do
      try try_color v i; iterate (Bfs.step iter); 
          assert false
      with NoColor -> ()
    done;
    Mark.set v 0; raise NoColor
  in
  try iterate (Bfs.start g); assert false 
  with Exit -> ()
\end{alltt}
The benefits of the persistent cursor are twofold: first, we could use
an existing traversal function without having to mix its code with the
coloring algorithm itself; second, the persistent nature of the
iterator avoids an explicit backtracking in the above code.

\subsection{Building Graphs}\label{builder}

In Section~\ref{interfaces}, we have shown that persistent and
imperative graphs have creation functions with different
signatures. However, as we have written algorithms in a generic way,
we may want to build graphs in a generic way, that is independently of
the underlying data structure. For instance, we may want to implement
graph operations (such as union, transitive closure, etc.) or to build
some classic graphs (such as the full graph with $n$ vertices, the de
Bruijn graph of order $n$, etc.) or even random graphs. In all these
cases, the persistent or imperative nature of the graph is not really
significant but the signature difference disallows genericity.

To solve this issue, we introduce a module \texttt{Builder}. It
defines a common interface for graphs building:
\begin{alltt}
module type S = sig
  module G : Sig.G
  val empty : unit -> G.t
  val copy : G.t -> G.t
  val add_vertex : G.t -> G.V.t -> G.t
  val add_edge : G.t -> G.V.t -> G.V.t -> G.t
  val add_edge_e : G.t -> G.E.t -> G.t
end
\end{alltt}
It is immediate to realize such a signature for persistent or
imperative graphs:
\begin{alltt}
module P(G : Sig.P) : S with module G = G
module I(G : Sig.I) : S with module G = G
\end{alltt}
It is important to notice that for imperative graphs the values
returned by the functions \texttt{add\_vertex},
\texttt{add\_edge} and \texttt{add\_edge\_e} are meaningless.

Therefore, it is easy to write a generic algorithm that builds
graphs. First we write a highly generic version as a functor taking a
module of signature \texttt{Builder.S} as argument:
\begin{alltt}
module Make(B : Builder.S) = struct ... end
\end{alltt}
and then we can trivially provide two variants of this functor for
both persistent and imperative graphs, with the following two lines:
\begin{alltt}
module P(G : Sig.P) = Make(Builder.P(G))
module I(G : Sig.I) = Make(Builder.I(G))
\end{alltt}
Thus the use of the module \texttt{Builder} is entirely hidden from
the user point of view.

\section{Using \ocamlgraph}\label{exemples}

This section demonstrates how to use \ocamlgraph's functors on two
typical situations: first, a direct use of \ocamlgraph's data
structures and algorithms to solve a problem; second, a more complex
situation where the user applies an \ocamlgraph's algorithm on his own
graph data structure.

\subsection{Sudoku}

This section illustrates the use of \ocamlgraph\ to solve the Sudoku
puzzle using graph coloring. This idea is to represent the Sudoku grid
as an undirected graph with $9\times 9$ vertices, each vertex being
connected to the other vertices on the same row, column or $3\times 3$
group. Then solving the Sudoku is equivalent to 9-coloring this graph.

First, we create a new graph data structure where vertices are labeled with
pairs of integers (the coordinates in the grid, as integers in the
range 0..8):
\begin{alltt}
module G = Imperative.Graph.Abstract
             (struct type t = int * int end)
\end{alltt}
We use the \texttt{Imperative} module since persistence is not
needed here, the \texttt{Graph} sub-module to indicate undirected
graphs and the \texttt{Abstract} functor both for efficiency and
simplicity. Indeed, such graphs come with integers marks on the vertices
that will be used here to store the colors.

Then we can create the graph itself:
\begin{alltt}
let g = G.create ()
\end{alltt}
This graph is initially empty. We need to create and add the 81
vertices. We could do it as simply as:
\begin{alltt}
for i = 0 to 8 do for j = 0 to 8 do 
  G.add_vertex g (G.V.create (i,j))
done done
\end{alltt}
but in order to access the vertices in the remaining of the code we
store them in a matrix:
\begin{alltt}
let vert = 
  let new_vertex i j = 
    let v = G.V.create (i, j) in 
    G.add_vertex g v; v in
  Array.init 9 (fun i -> Array.init 9 (new_vertex i))
\end{alltt}
Then we add the edges, connecting the vertices on a same row, column or group:
\begin{alltt}
for i = 0 to 8 do for j = 0 to 8 do
  for k = 0 to 8 do
    if k <> i then 
      G.add_edge g vert.(i).(j) vert.(k).(j);
    if k <> j then 
      G.add_edge g vert.(i).(j) vert.(i).(k);
  done;
  let gi = 3 * (i / 3) and gj = 3 * (j / 3) in
  for di = 0 to 2 do for dj = 0 to 2 do
    let i' = gi + di and j' = gj + dj in
    if i' <> i || j' <> j then 
      G.add_edge g vert.(i).(j) vert.(i').(j')
  done done
done done
\end{alltt}
The initial constraints in the Sudoku puzzle are set using the
\texttt{G.Mark.set} function.

To get the coloring algorithm for our graph data structure, we simply
apply the \texttt{Coloring.Mark} functor on \texttt{G}:
\begin{alltt}
module C = Coloring.Mark(G)
\end{alltt}
Finally, solving the Sudoku amounts to 9-coloring the graph \texttt{g}:
\begin{alltt}
C.coloring g 9
\end{alltt}

This code is almost as efficient as a hand-coded Sudoku solver: on the
average, a Sudoku puzzle is solved in 0.2 seconds (on a Pentium 4 2.4 GHz).

\begin{comment}
\subsection{Topological Sorting}

This section illustrates the use of one of \ocamlgraph's traversal
algorithms to perform some topological sorting on a set of files
dependencies. We assume given the following user-defined data
structure representing a file with its dependencies:
\begin{alltt}
type file = 
  \{ name : string ; mutable deps : file list \} 
\end{alltt}
In order to get the set of dependencies for a given file, we just have
to visit the underlying graph using a depth-first traversal. For that
purpose, we can use \ocamlgraph's \texttt{Graph.Traverse.Dfs}
functor (which is similar to the one presented Section~\ref{dfs}). To
do so, we need to build a 
module that implements the required graph operations.
First, we embed the \texttt{file} data type in a \texttt{Vertex} module:
\begin{alltt}
module Vertex = struct 
  type t = file 
  let compare n1 n2 = compare n1.name n2.name
  let hash n = Hashtbl.hash n.name
  let equal n1 n2 = n1.name = n2.name
end
\end{alltt}
Then viewing a list of files as a graph is easily implemented by the
following module: 
\begin{alltt}
module G = struct
  type t = file list

  module V = Vertex

  let iter_vertex = List.iter
  let fold_vertex = List.fold_right
  let iter_succ f _ v = List.iter f v.deps
  let fold_succ f _ v = List.fold_right f v.deps
end
\end{alltt}
Finally, we obtain the depth-first traversal module as a functor
instantiation: 
\begin{alltt}
module Dfs = Graph.Traverse.Dfs(G)
\end{alltt}
\end{comment}

\section{Benchmarks}\label{bench}

Surprisingly, we could not find any standard benchmark for graph
libraries. Thus we present here the results of a little benchmark of
our own, mostly to give the reader a rough idea of \ocamlgraph efficiency.
We test four different data structures for undirected
graphs with unlabeled edges, that are either persistent (P) or
imperative (I) and with either abstract (A) or concrete (C) vertices. In
the following they are referred to as PA, PC, IA and IC, respectively.
All tests were performed on a Pentium 4 2.4 GHz.

We first test the efficiency of graph creation and mutation. 
For that purpose, we build full graphs with $V$ vertices (and thus
$E=V(V+1)/2$ edges since we include self loops). 
Then we repeatedly delete all edges and vertices in these graphs. 
Figure~\ref{fig:bench:build} displays the creation and deletion
timings in seconds up to $V=1000$ (that is half a million of edges). 
The creation speed observed is roughly 100,000 edges per second for
imperative graphs. The creation of persistent graphs is slower but
within a constant factor (less than 2). Deletion is roughly twice
faster than creation.
Regarding memory consumption, all four data structures roughly use 5
machine words (typically 20 bytes) per edge.

\begin{figure*}
  \centering\hspace*{-2em}
  \begin{tabular}{cc}
  \begin{minipage}{0.5\linewidth}
    \input{./bench1c.tex}
  \end{minipage} &
  \begin{minipage}{0.5\linewidth}
  \input{./bench1d.tex}
  \end{minipage}
  \end{tabular}
  \caption{Benchmarking creation (left) and deletion (right)}
  \label{fig:bench:build}
\end{figure*}

Our second benchmark consists in building graphs corresponding to 2D
mazes, using a percolation algorithm, and then traversing them using
depth-first and breadth-first traversals. Given an integer $N$, we
build a graph with $V=N^2$ vertices and $E=V-1$
edges. Figure~\ref{fig:bench:maze} displays the timings in seconds for various
values of $N$ up to 600 (i.e. 360,000 vertices). The observed speed is
between 500,000 and 1 million traversed edges per second.

% on enleve Dijkstra parce que le resultat est bizarre
% \input{./bench2dij}

\begin{figure*}
  \centering\hspace*{-2em}
  \begin{tabular}{cc}
  \begin{minipage}{0.5\linewidth}
\input{./bench2dfs}
  \end{minipage} &
  \begin{minipage}{0.5\linewidth}
\input{./bench2bfs}
  \end{minipage}
  \end{tabular}
  \caption{Benchmarking DFS (left) and BFS (right)}
  \label{fig:bench:maze}
\end{figure*}

% memory use : pas probant ; donner plutot les chiffres directement
% ou mieux comparer avec la representation matricielle
% \input{./bench2mem}

We also tested the adjacency matrix-based data structure. Creation and
deletion are much faster in that case, and the data structure for
a dense graph is usually much more compact (it is implemented using bit
vectors). However, the use of this particular implementation is
limited to unlabeled imperative graphs with integer vertices. 
The above benchmarks, on the contrary, do not depend on the nature of
vertices and edges types. Thus they are much more representative of
\ocamlgraph average performances.


\section{Conclusion}

We have presented \ocamlgraph, a generic graph library for \ocaml\
providing several graph data structures and, independently, several
graph algorithms. This genericity is obtained using \ocaml's module
system and especially its functors which allow to share large pieces
of code.

To our knowledge, there is no library for any applicative language as
generic as \ocamlgraph. Regarding imperative languages, graph
libraries are rarely as generic and, anyway, never provide as many
different data structures.

Since its first release (Feb. 2004), the number of \ocamlgraph's users
is steadily increasing and several of them contributed code to the
library. Some of them provided new graph data structures (such as
\texttt{ConcreteBidirectional}) and others new algorithms
(e.g. minimal separators). It clearly shows the benefits of a generic
library where data structures and algorithms are separated.

% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.

% \acks

% Acknowledgments, if needed.

\nocite{*}
\bibliographystyle{plain}
\bibliography{./biblio}
% \begin{thebibliography}{}

% \bibitem{smith02}
% Smith, P. Q. reference text

% \end{thebibliography}

\end{document}
1-59593-090-6/05/0007
