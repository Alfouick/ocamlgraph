%-----------------------------------------------------------------------------
%
%               Template for LaTeX Class/Style File
%
% Name:         sigplanconf-template.tex
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[tfpsymp]{tfp05symp}

\usepackage{amsmath}
\usepackage{url}
\usepackage{xspace}
\usepackage{alltt}
\usepackage{verbatim,rotating}
%\usepackage{color}
%\usepackage[dvips]{epsfig}
\usepackage{graphicx}

\newcommand{\ocamlgraph}{\textsc{Ocamlgraph}\xspace}
\newcommand{\ocaml}{\textsc{Ocaml}\xspace}
\newcommand{\fl}{\ensuremath{\rightarrow}}

\begin{document}

%\conferenceinfo{GPCE '06}{October 22--26 2006, Portland, Oregon.} 
%\copyrightyear{2006} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{}        % These are ignored unless
%\preprintfooter{}   % 'preprint' option specified.

\title{Designing a Generic Graph Library \\ using ML Functors}
%\subtitle{}

%\authorinfo{Submitted for blind review}{}{}

\author
    {Sylvain Conchon\inst{1} \and 
     Jean-Christophe Filli\^atre\inst{1} \and 
     Julien Signoles\inst{2}\protect\footnote[1]{This work was mostly done
    while the third author was at LRI.}}
\authorrunning{S. Conchon \and J.-C. Filli\^atre \and J. Signoles}

\institute{LRI Universit\'e Paris Sud 91405 Orsay France \\
  \email{\{conchon,filliatr\}@lri.fr}
  \and Laboratoire S\^uret\'e des Logiciels, CEA-LIST \\
  \email{Julien.Signoles@cea.fr}}

%% \institute{LRI Universit\'e Paris Sud 91405 Orsay France \\
%%   \texttt{\{conchon,filliatr\}@lri.fr Julien.Signoles@cea.fr}}

%\email{conchon@lri.fr filliatr@lri.fr Julien.Signoles@cea.fr}


\maketitle

\begin{abstract}
  This article details the design and implementation of \ocamlgraph, a highly
  generic graph library for the programming language \ocaml. This
  library features a large set of graph data structures---directed or
  undirected, with or without labels on vertices and edges, as persistent
  or mutable data structures, etc.---and a large set of graph
  algorithms written independently of the graph data structure. Such a
  genericity is obtained through a massive use of \ocaml module system
  and of its functions, the so-called \emph{functors}.
\end{abstract}

%\category{D.2}{Software Engineering}{Software Architectures; Design;
%  Reusable Software}

%\terms
%term1, term2

%\keywords
%Graph library, Generic programming, Functors

\section{Introduction}

Finding a graph library for one's favorite programming language is
usually easy. But using the provided algorithms on one's
own graph data structure or building undirected persistent graphs with
vertices and edges labeled with something else than integers is
likely to be more difficult. Figure~\ref{comparison:tab} quickly
compares several graph libraries according to the following criteria: 
the number of graph data structures; the purely applicative or
imperative nature of the structures; and the ability to apply the
provided algorithms to a user graph data structure.
As we can notice, none of these libraries gives full satisfaction.
This article introduces
\ocamlgraph\footnote{\url{http://www.lri.fr/~filliatr/ocamlgraph/}}, a
highly generic graph library for the programming language
\ocaml~\cite{ObjectiveCaml}, which intends to fulfill all 
these criteria.

% Beside the mere presentation of this
% library, this article demonstrates how \ocaml has been used to
\ocamlgraph\ introduces genericity at two levels. First, \ocamlgraph
does not provide a single data structure for graphs but many of them,
enumerating all possible variations---directed or undirected graphs,
persistent or mutable data structures, user-defined labels on vertices
or edges, etc.---under a common interface.
Second, \ocamlgraph provides a large set of graph algorithms that are
written independently of the underlying graph data structure. Then
they can be applied on the data structures provided by \ocamlgraph
itself but also on user-defined data structures as soon as they
implement a minimal set of functionalities.

Without proper parameterization, such a large set of variants may
easily result into an unmanageable code. We avoid this pitfall
using the \ocaml module system~\cite{leroy00}, which
appears to be the tool of choice to do such meta-programming. 
The genericity of \ocamlgraph is indeed achieved through a massive use
of \ocaml functors. In the first case, they are used to avoid code
duplication between the many variations of graph data structures,
which is mandatory here seen the high number of similar but all
different implementations. In the second case, they are used to write
the graph algorithms independently of the underlying graph data
structure, with as much genericity as possible but also with an
efficiency concern in mind. 

% TODO
This article is organized as follows. Section~\ref{systememodules}
briefly introduces the \ocaml module system. Then
Section~\ref{structuresdedonnees} exposes the design of the common
interface for all graph data structures and explains how the code is
shared among the various implementations. Section~\ref{algos}
describes the algorithms provided in \ocamlgraph and how the
genericity with respect to the graph data structure is obtained.
Section~\ref{exemples} illustrates the use of \ocamlgraph\ on two
typical situations.  Finally Section~\ref{bench} presents some
benchmarks and Section~\ref{comparaison} compares \ocamlgraph with
several existing graph libraries.

% \section{Related Work}
% \label{comparaison}

% This section details the features of several other graph libraries, in
% order to make a comparison with \ocamlgraph. Our list is not
% exhaustive and only focuses on programming languages where some kind
% of generic programming is possible. Figure~\ref{comparison:tab}
% summarizes our comparison criteria which are mainly based on the
% genericity of the data structures and algorithms proposed by some
% other libraries.

\begin{figure*}[t]
\newcommand{\present}{\large\boldmath $\surd$}
\newcommand{\absent}{\large\boldmath $\oslash$}

  \centering
  \begin{tabular}{|l||c|c|c|c|c|}
    \hline
     &          & graph data & persistent / & generic    \\
     & language & structures & imperative   & algorithms \\\hline\hline
     GTL \cite{Gtl} & C++     & 1  & I & \absent   \\\hline
     LEDA \cite{Leda} & C++    & 2  & I & \absent   \\\hline
     BGL \cite{Bgl} & C++     & 2  & I & \present  \\\hline
     JDSL \cite{Jdsl} & Java   & 1  & I & \present  \\\hline
     FGL \cite{Fgl} & Haskell & 1  & P & \present  \\\hline
     MLRisc \cite{Mlrisc} & SML  & 1  & I & \absent   \\\hline
     Baire \cite{Baire}\footnotemark & \ocaml & 8 &P/I& ---      \\\hline
%     \ocamlgraph& \ocaml &P/I& \present & 19 \\\hline
  \end{tabular}
  \medskip
  \caption{Comparison with other graph libraries}
  \label{comparison:tab}
\end{figure*}
\footnotetext{The Baire library seems to be no longer available from the
  Internet at this day.}

\section{Motivating Example and Design Overview}

As a running example, we consider a Sudoku solver based on graph
coloring.  The idea is to represent the Sudoku grid as an undirected
graph with $9\times 9$ vertices, each vertex being connected to the
other vertices on the same row, column or $3\times 3$ group. Then
solving the Sudoku is equivalent to 9-coloring this graph.
What we should expect from a good graph library is thus:
\begin{enumerate}
\item the ability to easily build an undirected graph where each
  vertex is labeled with a pair of integers (the cell coordinates);
\item an efficient graph coloring algorithm that can be applied to the
  above data structure. 
\end{enumerate}
If a graph library is providing only directed graphs or only
unlabeled vertices, one has to adapt to the existing data structure.
Generally speaking, the user may want
to choose any combination of the following features:
\begin{itemize}
\item \emph{directed} or \emph{undirected} graphs;
\item \emph{labeled} or \emph{unlabeled} vertices and edges;
\item \emph{types} for the labels, when any;
\item \emph{persistent} or \emph{imperative} data structure;
\end{itemize}
The strong point in \ocamlgraph is to provide \emph{all} possible
combinations, as ML modules sharing a common signature \texttt{G}.
Then algorithms are provided as ML functors whose arguments must have
signatures compatible with \texttt{G}.

\section{Implementation}

We now describe the implementation of
\ocamlgraph. First Section~\ref{interface} describes the common
signature for all graph data structures.
Then Section~\ref{structuresdedonnees} details the various graph
implementations.

\subsection{Common Signature}\label{interface}

The common signature for all graph data structures includes an
abstract type \texttt{t} for the graphs, two modules \texttt{V} and
\texttt{E} for vertices and edges respectively, and all the
observers. The latter include several functions to iterate over
vertices and edges, which are massively used in graph algorithms. 
The common signature thus looks like:
\begin{verbatim}
module type G = sig
  type t
  module V : sig type t ... end
  module E : sig type t ... end
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
  ...
end
\end{verbatim}
Then we distinguish two signatures for persistent and imperative
graphs, \texttt{P} and \texttt{I} respectively, since the modifiers do
not have the same types:
\begin{verbatim}
module type P = sig
  include G
  val empty : t
  val add_vertex : t -> vertex -> t
  val add_edge : t -> vertex -> vertex -> t
  ...
end
module type I = sig
  include G
  val create : unit -> t
  val add_vertex : t -> vertex -> unit
  val add_edge : t -> vertex -> vertex -> unit
  ...
end
\end{verbatim}

\subsection{Graph Data Structures}\label{structuresdedonnees}

\ocamlgraph provides 16 graph data structures, which are all the
possible combinations of the following 4 criteria:
\begin{itemize}
\item \emph{directed} or \emph{undirected} graphs;
\item \emph{labeled} or \emph{unlabeled} edges;
\item \emph{persistent} or \emph{imperative} data structure;
\item \emph{concrete} or \emph{abstract} type for the vertices.
\end{itemize}
The last point requires some explanation: vertices are always labeled
but the user may choose between \emph{concrete} vertices where vertices and
their values are identical and \emph{abstract} vertices where the
values are hidden inside an abstract data type for vertices. The
former allows a more immediate use of the data structure and the
latter allows a more efficient implementation.

Each graph data structure is provided as a
functor, parameterized by user types for vertex labels and possibly edge
labels. These 16 
functors are displayed Figure~\ref{fig:interfaces} as square boxes
mapping signatures of input modules to signatures of output modules.
\begin{figure*}
  \centering
  %\includegraphics[width=\textwidth]{interface.pdf}    
  \includegraphics[width=\textwidth]{interface.eps} 
  \caption{\ocamlgraph's data structures components}\label{fig:interfaces}
\end{figure*}
Three other implementations complete the set of graph data structures,
namely \texttt{ConcreteBidirectional} for graphs with an efficient
access to predecessors, and
\texttt{Matrix.}(\texttt{Graph}, \texttt{Digraph}) for graphs
implemented as adjacency matrices.

Several functors are used to avoid code duplication among these
various implementations. For instance, one functor adds labels to
unlabeled graphs; another one encapsulates concrete vertices into an
abstract data type; etc.  Putting all together, the code size for the 19
graph data structures is about 1000 lines. This is clearly small
enough to be easily maintained. In Section~\ref{bench} we will show
that this code is also quite efficient.

The graph data structure for our Sudoku solver is thus simply obtained as
\begin{verbatim}
module G = Imperative.Graph.Abstract
             (struct type t = int * int end) 
\end{verbatim}
That is an imperative undirected graph with abstract vertices labeled
with pairs of integers and unlabeled edges.
Then we can create the graph itself with \texttt{G.create}, add
vertices with \texttt{G.add\_vertex} and edges with
\texttt{G.add\_edge}\footnote{The full source code for the Sudoku example is
  available on \ocamlgraph's web page.}.

\section{Algorithms}\label{algos}

This section introduces the second use of functors in \ocamlgraph: the
generic programming of graph algorithms.

\subsection{Generic Programming}

As demonstrated in the previous section, our library provides many
graph data structures. Therefore, it is necessary to figure out how to
implement graph algorithms without duplicating code for each data
structure. Exactly as functors helped factorizing code in the previous
section, they provide a nice way to code the algorithms in a generic
way.

The basic idea is to code an algorithm without worrying about the
underlying graph data structure but focusing only on the required
operations over this data structure. Then the algorithm is naturally a
functor parameterized by these operations. Such operations usually
make a subset of the operations provided by \ocamlgraph's own data
structures, but some algorithms may require specific operations,
independent of the graph data structure. In such a case, they will be
provided as an additional functor parameter.

Such a ``functorization'' of algorithms has two benefits: first, it
allows to quickly add a new algorithm to the library, without code
duplication for all data structures; second, it allows the user to
apply an algorithm on its own graph data structure%% , which is an
%% original feature of \ocamlgraph\ w.r.t. other graph libraries.

\subsection{Example: Graph Coloring}
\label{coloring}

We illustrate the generic programming of graph algorithms on the
particular example of graph coloring.  For the purpose of our
algorithm, we assume vertices to be equipped with integer marks, used
to store the assigned colors. We also need iterators over vertices and
successors. Thus the minimal signature for a graph
coloring algorithm is the following:
\begin{verbatim}
module type GM = sig
  type t
  module V : sig type t ... end
  module Mark : sig
    val get : V.t -> int
    val set : V.t -> int -> unit
  end
  val iter_vertex : (V.t -> unit) -> t -> unit
  val iter_succ : (V.t -> unit) -> t -> V.t -> unit
end
\end{verbatim}
\ocamlgraph already provides implementations for such a
signature. This is the case for the graph data structure used in our
Sudoku solver.

Then the graph coloring algorithm is implemented as the following functor:
\begin{verbatim}
module Coloring(G : GM) : sig
  val coloring : G.t -> int -> unit
end
\end{verbatim}
It provides a single function \texttt{coloring} which colors a given
graph with a given number of colors. Some marks may contain initial
constraints. 

To complete our Sudoku solver, we simply need to apply the above
functor on our graph module \texttt{G}:
\begin{alltt}
module C = Coloring(G)
\end{alltt}
If \texttt{g} contains the Sudoku graph, and
assuming that the initial constraints are set in \texttt{g}'s marks, 
solving the Sudoku amounts to 9-coloring the graph \texttt{g}:
\begin{alltt}
C.coloring g 9
\end{alltt}
This code is almost as efficient as a hand-coded Sudoku solver: on the
average, a Sudoku puzzle is solved in 0.2 seconds (on a Pentium 4 2.4 GHz).

\section{Benchmarks}\label{bench}

Surprisingly, we could not find any standard benchmark for graph
libraries. Thus we present here the results of a little benchmark of
our own, mostly to give the reader a rough idea of \ocamlgraph efficiency.
We test four different data structures for undirected
graphs with unlabeled edges, that are either persistent (P) or
imperative (I) and with either abstract (A) or concrete (C) vertices. In
the following they are referred to as PA, PC, IA and IC, respectively.
All tests were performed on a Pentium 4 2.4 GHz.

We first test the efficiency of graph creation and mutation. 
For that purpose, we build full graphs with $V$ vertices (and thus
$E=V(V+1)/2$ edges since we include self loops). 
Then we repeatedly delete all edges and vertices in these graphs. 
Figure~\ref{fig:bench:build} displays the creation and deletion
timings in seconds up to $V=1000$ (that is half a million of edges). 
The creation speed observed is roughly 100,000 edges per second for
imperative graphs. The creation of persistent graphs is slower but
within a constant factor (less than 2). Deletion is roughly twice
faster than creation.
Regarding memory consumption, all four data structures roughly use 5
machine words (typically 20 bytes) per edge.

\begin{figure*}
  \centering%\hspace*{-2em}
  \input{./bench1c.tex}

  \input{./bench1d.tex}
%%   \begin{tabular}{cc}
%%   \begin{minipage}{0.5\linewidth}
%%     \input{./bench1c.tex}
%%   \end{minipage} &
%%   \begin{minipage}{0.5\linewidth}
%%   \input{./bench1d.tex}
%%   \end{minipage}
%%   \end{tabular}
  \caption{Benchmarking creation (left) and deletion (right)}
  \label{fig:bench:build}
\end{figure*}

Our second benchmark consists in building graphs corresponding to 2D
mazes, using a percolation algorithm, and then traversing them using
depth-first and breadth-first traversals. Given an integer $N$, we
build a graph with $V=N^2$ vertices and $E=V-1$
edges. Figure~\ref{fig:bench:maze} displays the timings in seconds for various
values of $N$ up to 600 (i.e. 360,000 vertices). The observed speed is
between 500,000 and 1 million traversed edges per second.

% on enleve Dijkstra parce que le resultat est bizarre
% \input{./bench2dij}

\begin{figure*}
  \centering%% \hspace*{-2em}
%%   \begin{tabular}{cc}
%%   \begin{minipage}{0.5\linewidth}
%% \input{./bench2dfs}
%%   \end{minipage} &
%%   \begin{minipage}{0.5\linewidth}
%% \input{./bench2bfs}
%%   \end{minipage}
%%   \end{tabular}
  \input{./bench2dfs}

  \input{./bench2bfs}
  \caption{Benchmarking DFS (left) and BFS (right)}
  \label{fig:bench:maze}
\end{figure*}

% memory use : pas probant ; donner plutot les chiffres directement
% ou mieux comparer avec la representation matricielle
% \input{./bench2mem}

We also tested the adjacency matrix-based data structure. Creation and
deletion are much faster in that case, and the data structure for
a dense graph is usually much more compact (it is implemented using bit
vectors). However, the use of this particular implementation is
limited to unlabeled imperative graphs with integer vertices. 
The above benchmarks, on the contrary, do not depend on the nature of
vertices and edges types. Thus they are much more representative of
\ocamlgraph average performances.


\section{Conclusion}

We have presented \ocamlgraph, a highly generic graph library for \ocaml\
providing several graph data structures and, independently, several
graph algorithms. This genericity is obtained using \ocaml's module
system and especially its functors which allow to share large pieces
of code.

To our knowledge, there is no library for any applicative language as
generic as \ocamlgraph. Regarding imperative languages, graph
libraries are rarely as generic and, anyway, never provide as many
different data structures.

Since its first release (Feb. 2004), the number of \ocamlgraph's users
is steadily increasing and several of them contributed code to the
library. Some of them provided new graph data structures (such as
\texttt{ConcreteBidirectional}) and others new algorithms
(e.g. minimal separators). It clearly shows the benefits of a generic
library where data structures and algorithms are separated.

% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.

% \acks

% Acknowledgments, if needed.

\nocite{*}
\bibliographystyle{plain}
\bibliography{./biblio}
% \begin{thebibliography}{}

% \bibitem{smith02}
% Smith, P. Q. reference text

% \end{thebibliography}

\end{document}
%1-59593-090-6/05/0007
