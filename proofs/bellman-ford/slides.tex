\documentclass{beamer}

%\usetheme{Madrid}
\usetheme{Marburg}
%\usetheme{Goettingen}
%\usetheme{PaloAlto}
\usecolortheme{beaver}
%\usecolortheme{crane}
\usefonttheme{structurebold}

\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{amssymb,amsmath,amsthm}

\setbeamertemplate{footline}{
\hfill\scriptsize{\color{white}\insertframenumber}\hspace*{24pt}\vspace{8pt}}
\setbeamertemplate{navigation symbols}{}

\lstset{basicstyle=\footnotesize, columns=fullflexible}
\lstdefinelanguage{Ocaml}
{
basicstyle=\ttfamily,
keywordstyle=\color{blue},
morekeywords=[1]{exception,of,val},%
%keywordstyle=[1]{\color{red}},%
morekeywords=[2]{true,false},%
%keywordstyle=[2]{\color{blue}},%
otherkeywords={},%
commentstyle=\itshape,%
columns=[l]fullflexible,%
sensitive=true,%
morecomment=[s]{(*}{*)},%
escapeinside={*?}{?*},%
keepspaces=true,
literate=%
{<}{$<$}{1}%
{>}{$>$}{1}%
{<=}{$\le$}{1}%
{>=}{$\ge$}{1}%
{<>}{$\ne$}{1}%
{->}{$\rightarrow$}{2}%
{<->}{$\leftrightarrow$}{2}%
}

\lstdefinelanguage{Why3}
{
basicstyle=\ttfamily,
keywordstyle=\color{blue},
morekeywords=[1]{inductive,predicate,function,goal,type,use,import,theory,end,in,axiom,lemma,export,forall,constant,module,let,exception,match,with,exists},%
%keywordstyle=[1]{\color{red}},%
morekeywords=[2]{true,false},%
%keywordstyle=[2]{\color{blue}},%
otherkeywords={},%
commentstyle=\itshape,%
columns=[l]fullflexible,%
sensitive=true,%
morecomment=[s]{(*}{*)},%
escapeinside={*?}{?*},%
keepspaces=true,
literate=%
{'a}{$\alpha$}{1}%
{'b}{$\beta$}{1}%
{<}{$<$}{1}%
{>}{$>$}{1}%
{<=}{$\le$}{1}%
{>=}{$\ge$}{1}%
{<>}{$\ne$}{1}%
{/\\}{$\land$}{1}%
{\\/}{ $\lor$ }{3}%
{\ or(}{ $\lor$(}{3}%
{not\ }{$\lnot$ }{1}%
{not(}{$\lnot$(}{1}%
{->}{$\rightarrow$}{2}%
{<->}{$\leftrightarrow$}{2}%
}

\lstnewenvironment{why3}
{\lstset{language=Why3}}
{}

\begin{document}

\title{A Formal Proof of Bellman-Ford Algorithm}
\author[Yuto Takei]{Yuto Takei}
\institute{The University of Tokyo}

\maketitle

\begin{frame}\frametitle{Table of contents}
\tableofcontents
\end{frame}

\section{Bellman-Ford Algorithm}
\frame{\sectionpage}

\subsection{Introduction}

\begin{frame}\frametitle{Bellman-Ford Algorithm}

Solution for single-source shortest path problem $(G,s,l)$

\begin{itemize}
\item Directed graph $G(V,E)$
\item Source vertex $s\in V$
\item Length function $l: E\to \mathbf{R}$
\end{itemize}

\pause

The algorithm will either

\begin{itemize}
\item give shortest-paths to all vertices from $s$, or
\item assert the existence of a negative cycle.
\end{itemize}

\end{frame}

\begin{frame}\frametitle{For example...}

\only<1>{\includegraphics[width=1.0\textwidth]{intro1.pdf}
}\only<2>{\includegraphics[width=1.0\textwidth]{intro2.pdf}
}\only<3>{\includegraphics[width=1.0\textwidth]{intro3.pdf}
}\only<4>{\includegraphics[width=1.0\textwidth]{intro4.pdf}
}

\begin{itemize} 
\only<1-2>{\onslide<2>{\item Gave distances from source to all vertices}}
\only<3-4>{\onslide<4>{\item Found a negative cycle}}
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Goal (revisited)}

Each node has a tuple $(\pi,d)$ containing parent and distance.

\includegraphics[width=1.0\textwidth]{intro5.pdf}

After the algorithm termination,
\begin{itemize}
\item all node have the smallest possible distance from $s$, and
\item the shortest path tree is built by traversing $\pi$
\end{itemize}

\end{frame}

\subsection{Mechanism}

\begin{frame}\frametitle{How does it work?}

\begin{enumerate}

\item \alert{Initialization}

Set $(nil,\infty)$ for all vertex except $s$ having $(nil,0)$.\newline

\item \alert{Relaxing edges}

If $v$ is reachable with less distance by $(u,v)$, update. 

\only<1-2>{\begin{center}\onslide<2>\includegraphics[width=0.7\textwidth]{rlx1.pdf}\end{center}
}\only<3->{\begin{center}\includegraphics[width=0.7\textwidth]{rlx2.pdf}\end{center}
}\onslide<4>{Perform this over all edges for $|V|-1$ times.}

\end{enumerate}

\end{frame}

\begin{frame}\frametitle{Example}
\only<1>{Pass \#0 - just after initialization
\includegraphics[width=0.9\textwidth]{ex1.pdf}
}\only<2>{Pass \#1
\includegraphics[width=0.9\textwidth]{ex2.pdf}
}\only<3>{Pass \#1
\includegraphics[width=0.9\textwidth]{ex3.pdf}
}\only<4>{Pass \#1
\includegraphics[width=0.9\textwidth]{ex4.pdf}
}\only<5>{Pass \#1
\includegraphics[width=0.9\textwidth]{ex5.pdf}
}\only<6>{Pass \#2
\includegraphics[width=0.9\textwidth]{ex6.pdf}
}\only<7>{Pass \#3
\includegraphics[width=0.9\textwidth]{ex7.pdf}
}

\end{frame}

\begin{frame}\frametitle{How does it work? (cont.)}

\begin{enumerate}
\setcounter{enumi}{2}

\item \alert{Still be able to relax?}

After $(|V|-1)$-th pass, all vertices should be exact.
Otherwise, a negative cycle exists.

\end{enumerate}

\end{frame}

\begin{frame}\frametitle{$\mbox{\sc Bellman-Ford}(G,s,l)$}

\begin{algorithmic}[1]
\STATE{$\mbox{\sc Initialize-Single-Source}(G,s)$}
\FOR{$i=1\to |V[G]|-1$}
\FORALL{edge $(u,v) \in E[G]$}
\STATE{$\mbox{\sc Relax}(u,v,l)$}
\ENDFOR
\ENDFOR
\FORALL{edge $(u,v)\in E[G]$}
\IF{$d[v]>d[u]+l(u,v)$}
\RETURN{False}
\ENDIF
\ENDFOR
\RETURN{True}
\end{algorithmic}

\cite[p.~532]{algo}

\end {frame}

\section{Implementation in OCamlgraph}
\frame{\sectionpage}
% up to 5 slides
  % focus on the API
  % incremental version as well

\begin{frame}[fragile]\frametitle{Work that has been done}

\begin{enumerate}
\item Implementation of Bellman-Ford algorithm

\begin{lstlisting}[language=Ocaml]
exception Negative_cycle of G.E.t list

val all_shortest_paths:
             G.t -> G.V.t -> W.t H.t

val find_negative_cycle_from:
             G.t -> G.V.t -> G.E.t list
\end{lstlisting} \vspace*{10pt}

\pause
\item Negative cycle detection from any source

\begin{lstlisting}[language=Ocaml]
val find_negative_cycle: G.t -> G.E.t list
\end{lstlisting}

\end{enumerate}

\end{frame}


\begin{frame}\frametitle{Negative cycle detection from any source}

\vspace*{8pt}
\only<1>{Want to ensure that $G$ is free of any negative cycles.\vspace*{-18pt}
}\only<2>{Checking from specific $s$ is not exhaustive.\vspace*{-14pt}
}\only<3>{\alert{Solution:} To give a ``virtual'' $s$ that can reach all nodes.}

\begin{center}
\only<1>{\includegraphics[height=0.8\textheight]{s1.pdf}
}\only<2>{\includegraphics[height=0.8\textheight]{s2.pdf}
}\only<3>{\includegraphics[width=0.8\textwidth]{s3.pdf}
}\end{center}

\only<3>{$s$ connects to one of the elements in every top ancestor among
strongly connected components.\vspace{100pt}}

\end{frame}


\begin{frame}[fragile]\frametitle{Work that has been done (cont.)}

\begin{enumerate}
\setcounter{enumi}{2}
\item Incremental graph builder w/o negative cycle\newline

Keep track of
\begin{itemize}
\item the set of ancestors $S$, and
\item distances from each ancestor to every node $d_s(v)$
\end{itemize}

When adding
\begin{itemize}
\item\alert{vertex $v$}, just add $v$ to $S$.
\item\alert{edge $(u,v)$}, if $v\in S$, check if $(u,v)$ causes a loop.\newline
If not, $S\leftarrow S\backslash v$. Propagate distance to descendants.
\end{itemize}

When removing
\begin{itemize}
\item\alert{vertex $v$}, remove all edges $(v,w)$ then $v$ itself.
\item\alert{edge $(u,v)$}, correct the distances of $v$ and propagate.
\end{itemize}

\end{enumerate}

\end{frame}

\section{Formal proof with Why3}
\frame{\sectionpage}

\subsection{Specification}

\begin{frame}[fragile]\frametitle{Terminability}

Loop variants are trivial and easily given.\vspace*{12pt}

\begin{algorithmic}[1]
\STATE{$\mbox{\sc Initialize-Single-Source}(G,s)$}
\FOR{\alert{$i=1\to |V[G]|-1$}}
\FORALL{\alert{edge $(u,v)\in E[G]$}}
\STATE{$\mbox{\sc Relax}(u,v,l)$}
\ENDFOR
\ENDFOR
\FORALL{\alert{edge $(u,v)\in E[G]$}}
\IF{$d[v]>d[u]+l(u,v)$}
\RETURN{False}
\ENDIF
\ENDFOR
\RETURN{True}
\end{algorithmic}

\end{frame}

\begin{frame}[fragile]\frametitle{Correctness}

\begin{itemize}

\item \alert{Precondition}

\begin{lstlisting}[language=why3]
mem s vertices
\end{lstlisting}

\item \alert{Postcondition} when terminates with success
\begin{lstlisting}[language=why3]
forall v: vertex. mem v vertices ->
match result[v] with
  | Infinite -> no_path s v
  | Finite n -> shortest_path s v n
end
\end{lstlisting}

\item \alert{Postcondition} when detects a negative cycle
\begin{lstlisting}[language=why3]
exists v: vertex. mem v vertices /\
exists n: int. n < 0 /\ path v v n
\end{lstlisting}
\end{itemize}

\end{frame}

\subsection{Proof}

% code
% additional definitions/lemmas for the proof
% additional annotations for the proof
% loop invariants

\begin{frame}\frametitle{}
\end{frame}


\section{Conclusion and Perspectives}

% what's next, still to be done, etc.





\section{Bibliography}
\begin{frame}

\bibliographystyle{plain}
\bibliography{./biblio}

\end{frame}

\end{document}
