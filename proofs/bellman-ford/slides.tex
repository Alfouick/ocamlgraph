\documentclass{beamer}

%\usetheme{Madrid}
\usetheme{Marburg}
%\usetheme{Goettingen}
%\usetheme{PaloAlto}
\usecolortheme{beaver}
%\usecolortheme{crane}
\usefonttheme{structurebold}

\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{amssymb,amsmath,amsthm}

\lstdefinelanguage{Why3}
{
basicstyle=\ttfamily,
keywordstyle=\color{blue},
morekeywords=[1]{inductive,predicate,function,goal,type,use,import,theory,end,in,axiom,lemma,export,forall,constant,module,let,exception,match,with,exists},%
%keywordstyle=[1]{\color{red}},%
morekeywords=[2]{true,false},%
%keywordstyle=[2]{\color{blue}},%
otherkeywords={},%
commentstyle=\itshape,%
columns=[l]fullflexible,%
sensitive=true,%
morecomment=[s]{(*}{*)},%
escapeinside={*?}{?*},%
keepspaces=true,
literate=%
{'a}{$\alpha$}{1}%
{'b}{$\beta$}{1}%
{<}{$<$}{1}%
{>}{$>$}{1}%
{<=}{$\le$}{1}%
{>=}{$\ge$}{1}%
{<>}{$\ne$}{1}%
{/\\}{$\land$}{1}%
{\\/}{ $\lor$ }{3}%
{\ or(}{ $\lor$(}{3}%
{not\ }{$\lnot$ }{1}%
{not(}{$\lnot$(}{1}%
{->}{$\rightarrow$}{2}%
{<->}{$\leftrightarrow$}{2}%
%
%
}

\lstnewenvironment{why3}
{\lstset{language=Why3}}
{}

\begin{document}

\title{A Formal Proof of Bellman-Ford Algorithm}
\author[Yuto Takei]{Yuto Takei}
\institute{The University of Tokyo}

\maketitle

\begin{frame}\frametitle{Table of contents}
\tableofcontents
\end{frame}

\section{Bellman-Ford Algorithm}

\subsection{Introduction}

\begin{frame}\frametitle{Bellman-Ford Algorithm}

Solution for single-source shortest path problem $(G,s,l)$

\begin{itemize}
\item Directed graph $G(V,E)$
\item Source vertex $s\in V$
\item Length function $l: E\to \mathbf{R}$
\end{itemize}

\pause

The algorithm will either

\begin{itemize}
\item give shortest-paths to all vertices from $s$, or
\item assert the existence of a negative cycle.
\end{itemize}

\end{frame}

\begin{frame}\frametitle{For example...}

\only<1>{\includegraphics[width=1.0\textwidth]{intro1.pdf}
}\only<2>{\includegraphics[width=1.0\textwidth]{intro2.pdf}
}\only<3>{\includegraphics[width=1.0\textwidth]{intro3.pdf}
}\only<4>{\includegraphics[width=1.0\textwidth]{intro4.pdf}
}

\begin{itemize}
\only<1-2>{\onslide<2>{\item Gave distances from source to all vertices}}
\only<3-4>{\onslide<4>{\item Found a negative cycle}}
\end{itemize}

\end{frame}

\begin{frame}\frametitle{Goal (revisited)}

Each node has a tuple $(\pi,d)$ containing parent and distance.

\includegraphics[width=1.0\textwidth]{intro5.pdf}

After the algorithm termination,
\begin{itemize}
\item all node have the smallest possible distance from $s$, and
\item the shortest path tree is built by traversing $\pi$
\end{itemize}

\end{frame}

\subsection{Mechanism}

\begin{frame}\frametitle{How does it work?}

\begin{enumerate}

\item \alert{Initialization}

Set $(null,\infty)$ for all vertex except $s$ having $(null,0)$.\newline

\pause

\item \alert{Relaxing edges}

If $w$ is reachable with less distance by $(v,w)$, update. Perform this
over all edges for $|V|-1$ times.

\begin{center}
\only<1>{\includegraphics[width=0.7\textwidth]{rlx1.pdf}
}\only<2->{\includegraphics[width=0.7\textwidth]{rlx2.pdf}
}
\end{center}

\pause

\onslide<3>{\item \alert{Still able to relax?}

Something is strange... negative cycle!
}
\end{enumerate}

\end{frame}

\begin{frame}\frametitle{Example}
\only<1>{Pass \#0 - just after initialization
\includegraphics[width=0.9\textwidth]{ex1.pdf}
}\only<2>{Pass \#1
\includegraphics[width=0.9\textwidth]{ex2.pdf}
}\only<3>{Pass \#1
\includegraphics[width=0.9\textwidth]{ex3.pdf}
}\only<4>{Pass \#1
\includegraphics[width=0.9\textwidth]{ex4.pdf}
}\only<5>{Pass \#1
\includegraphics[width=0.9\textwidth]{ex5.pdf}
}\only<6>{Pass \#2
\includegraphics[width=0.9\textwidth]{ex6.pdf}
}\only<7>{Pass \#3
\includegraphics[width=0.9\textwidth]{ex7.pdf}
}


\end{frame}

\begin{frame}\frametitle{$ \mbox{\sc Bellman-Ford} (G,s,l) $}

\begin{algorithmic}[1]
\STATE{$ \mbox{\sc Initialize-Single-Source} (G,s) $}
\FOR{$i = 1 \to |V[G]|-1 $}
\FORALL{ edge $ (u,v) \in E[G] $}
\STATE{$ \mbox{\sc Relax} (u,v,l) $}
\ENDFOR
\ENDFOR
\FORALL{edge $ (u,v)\in E[G] $}
\IF{$ d[v]>d[u]+l(u,v) $}
\RETURN{False}
\ENDIF
\ENDFOR
\RETURN{True}
\end{algorithmic}

\cite[p.~532]{algo}

\end {frame}

\section{Implementation in OCamlgraph}
% up to 5 slides
  % focus on the API
  % incremental version as well

\begin{frame}[fragile]\frametitle{Work that has been done}

\begin{enumerate}
\item Implementation of Bellman-Ford algorithm

\begin{lstlisting}[language=caml]
exception NegativeCycle of G.E.t list
val all_shortest_paths : G.t -> G.V.t -> W.t H.t
\end{lstlisting}

\pause
\item Negative cycle detection from any source
\item Incremental graph builder w/o negative cycle
\end{enumerate}

\end{frame}


\begin{frame}\frametitle{Detection from any source}

Want to ensure that $G$ is free of any negative cycle.

\begin{center} \includegraphics[width=0.8\textwidth]{s1.pdf} \end{center}

\end{frame}


\begin{frame}\frametitle{}

If given $s$ was pointing something, 

\begin{center} \includegraphics[width=0.8\textwidth]{s2.pdf} \end{center}

\end{frame}

\begin{frame}\frametitle{}

\begin{center} \includegraphics[width=0.8\textwidth]{s3.pdf} \end{center}

\end{frame}

\section{Formal proof with Why3}
% 10 slides

\subsection{Specification}

\begin{frame}\frametitle{Correctness of the algorithm}

\begin{itemize}
\item Terminability
\item 
\end{itemize}

\end{frame}

% definitions (graphs, paths, for the specification)
% + program specification (pre/post)

\begin{frame}[fragile]\frametitle{Title}

\begin{lstlisting}[language=why3]

not negcycle /\
forall v: vertex. mem v vertices ->
match result[v] with
  | Infinite -> no_path s v
  | Finite n -> exists d: int. shortest_path s v n d
end


\end{lstlisting}

\end{frame}

\subsection{Proof}

% code
% additional definitions/lemmas for the proof
% additional annotations for the proof
% loop invariants

\begin{frame}\frametitle{}
\end{frame}


\section{Conclusion and Perspectives}

% what's next, still to be done, etc.





\section{Bibliography}
\begin{frame}

\bibliographystyle{plain}
\bibliography{./biblio}

\end{frame}

\end{document}
