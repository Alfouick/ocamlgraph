
(* A proof of Bellman-Ford algorithm

   By Yuto Takei (University of Tokyo, Japan)
   and Jean-Christophe FilliÃ¢tre (CNRS, France). *)

theory Graph

  use export list.Length
  use export int.Int
  use export set.Fset

  (* the graph is defined by a set of vertices and a set of edges *)
  type vertex
  constant vertices: set vertex
  constant edges: set (vertex, vertex)

  predicate edge (x y: vertex) = mem (x,y) edges

  (* edges are well-formed *)
  axiom edges_def:
    forall x y: vertex.
    mem (x, y) edges -> mem x vertices /\ mem y vertices

  (* a single source vertex s is given *)
  constant s: vertex
  axiom s_in_graph: mem s vertices

  (* hence vertices is non empty *)
  lemma vertices_cardinal_pos: cardinal vertices > 0

  (* paths *)
  clone export graph.IntPathWeight
     with type vertex = vertex, predicate edge = edge

  lemma path_in_vertices:
    forall v1 v2: vertex, l: list vertex.
    mem v1 vertices -> path v1 l v2 -> mem v2 vertices

  (* simple path *)
  lemma simple_path:
    forall v: vertex, l: list vertex. path s l v ->
    exists l': list vertex. path s l' v /\ length l' < cardinal vertices

  (* negative cycle [v] -> [v] reachable from [s] *)
  predicate negative_cycle (v: vertex) =
    mem v vertices /\
    (exists l1: list vertex. path s l1 v) /\
    (exists l2: list vertex. path v l2 v /\ path_weight l2 v < 0)

  (* key lemma for existence of a negative cycle *)
  lemma key_lemma_1:
    forall v: vertex, n: int.
    (* if any simple path has weight at least n *)
    (forall l: list vertex.
       path s l v -> length l < cardinal vertices -> path_weight l v >= n) ->
    (* and if there exists a shorter path *)
    (exists l: list vertex. path s l v /\ path_weight l v < n) ->
    (* then there exists a nagtive cycle *)
    exists u: vertex. negative_cycle u

end

module BellmanFord

  use import map.Map
  use import Graph
  use int.IntInf as D

  use import module ref.Ref
  use module bag.Bag

  type distmap = map vertex D.t

  function initialize_single_source (s: vertex) : distmap =
    (const D.Infinite)[s <- D.Finite 0]

  (* [inv1 m pass via] means that we already performed [pass-1] steps
     of the main loop, and, in step [pass], we already processed edges
     in [via] *)
  predicate inv1 (m: distmap) (pass: int) (via: set (vertex, vertex)) =
    forall v: vertex. mem v vertices ->
    match m[v] with
      | D.Finite n ->
        (* there exists a path of weight [n] *)
        (exists l: list vertex. path s l v /\ path_weight l v = n) /\
        (* there is no shorter path in less than [pass] steps *)
        (forall l: list vertex.
           path s l v -> length l < pass -> path_weight l v >= n) /\
        (* and no shorter path in i steps with last edge in [via] *)
        (forall u: vertex, l: list vertex.
           path s l u -> length l < pass -> mem (u,v) via ->
           path_weight l u + weight u v >= n)
      | D.Infinite ->
        (* any path has at least [pass] steps *)
        (forall l: list vertex. path s l v -> length l >= pass) /\
        (* [v] cannot be reached by [(u,v)] in [via] *)
        (forall u: vertex. mem (u,v) via -> (*m[u] = D.Infinite*)
          forall lu: list vertex. path s lu u -> length lu >= pass)
    end

  predicate inv2 (m: distmap) (via: set (vertex, vertex)) =
    forall u v: vertex. mem (u, v) via ->
    D.le m[v] (D.add m[u] (D.Finite (weight u v)))

  (* key lemma for non-existence of a negative cycle *)
  lemma key_lemma_2:
     forall m: distmap. inv2 m edges ->
     forall v: vertex. not (negative_cycle v)

  let relax (m: ref distmap) (u v: vertex) (pass: int)
            (via: set (vertex, vertex)) =
    { 1 <= pass /\ mem (u, v) edges /\ not (mem (u, v) via) /\
      inv1 !m pass via }
    let n = D.add !m[u] (D.Finite (weight u v)) in
    if D.lt n !m[v] then m := !m[v <- n]
    { inv1 !m pass (add (u, v) via) }

  exception NegativeCycle

  let bellman_ford () =
    { }
    let m = ref (initialize_single_source s) in
    for i = 1 to cardinal vertices - 1 do
      invariant { inv1 !m i empty }
      let es = Bag.create edges in
      while not (Bag.is_empty es) do
        invariant { subset !es edges /\ inv1 !m i (diff edges !es) }
        variant   { cardinal !es }
        let via = diff edges !es in (* ghost *)
        let (u, v) = Bag.pop es in
        relax m u v i via
      done;
      assert { inv1 !m i edges }
    done;
    assert { inv1 !m (cardinal vertices) empty };
    let es = Bag.create edges in
    while not (Bag.is_empty es) do
      invariant { subset !es edges /\ inv2 !m (diff edges !es) }
      variant { cardinal !es }
      let (u, v) = Bag.pop es in
      if D.lt (D.add !m[u] (D.Finite (weight u v))) !m[v] then begin
        raise NegativeCycle
      end
    done;
    assert { inv2 !m edges };
    !m
    { forall v: vertex. mem v vertices ->
      match result[v] with
        | D.Finite n ->
            (exists l: list vertex. path s l v /\ path_weight l v = n) /\
            (forall l: list vertex. path s l v -> path_weight l v >= n)
        | D.Infinite ->
            (forall l: list vertex. not (path s l v))
      end }
    | NegativeCycle ->
      { exists v: vertex. negative_cycle v }

end

(*
Local Variables:
compile-command: "why3ide bf.mlw"
End:
*)
