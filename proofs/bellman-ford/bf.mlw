
(* Proof of Bellman-Ford algorithm *)

theory Graph

  use export int.Int
  use export set.Fset

  type vertex
  function vertices : set vertex
  function succ vertex : set vertex
  function weight vertex vertex : int

  (* there is a path of length n from v1 to v2 *)
  inductive path (v1 v2: vertex) (n: int) =
    | path_empty:
        forall v: vertex. path v v 0
    | path_succ:
        forall v1 v2 v3: vertex, n: int.
        path v1 v2 n -> mem v3 (succ v2) -> path v1 v3 (n + weight v2 v3)

  predicate shortest_path (v1 v2: vertex) (n: int) =
    path v1 v2 n /\
    forall m: int. m < n -> not (path v1 v2 m)

  predicate no_path (v1 v2: vertex) =
    forall n: int. not (path v1 v2 n)

end

module BellmanFord

  use import map.Map
  use import Graph
  use import module ref.Ref

  type dist = Finite int | Infinite

  type distmap = map vertex dist

  function initialize_single_source (s: vertex) : distmap =
    (const Infinite)[s <- Finite 0]

  function add_dist (x: dist) (y: dist) : dist =
    match x with
      | Infinite -> Infinite
      | Finite x ->
	match y with
	  | Infinite -> Infinite
	  | Finite y -> Finite (x + y)
	end
    end

  function compare_dist (x: dist) (y: dist) : int =
    match x with
      | Infinite ->
	match y with
	  | Infinite -> 0
	  | Finite _ -> 1
	end
      | Finite x ->
	match y with
	  | Infinite -> -1
	  | Finite y -> x - y
	end
    end

  let relax (m: ref distmap) (u: vertex) (v: vertex) =
    let new_dv = add_dist (get !m u) (Finite (weight u v)) in
    if compare_dist (get !m v) new_dv > 0 then
      set !m v new_dv

  exception NegativeCycle (* list vertex *)

  let bellman_ford (s: vertex) =
    { mem s vertices }
    let m = ref (initialize_single_source s) in



    if any bool then raise NegativeCycle;


    !m

    { (* the returned map contains the shortest distance from s to any
         reachable vertex *)
      forall v: vertex. mem v vertices ->
        match result[v] with
        | Finite n -> shortest_path s v n
        | Infinite -> no_path s v
        end
    }
    | NegativeCycle ->
    { (* there is (at least) one negative cycle *)
      exists v: vertex. mem v vertices /\
      exists n: int. n < 0 /\ path v v n  }

end

(*
Local Variables:
compile-command: "why3ide bf.mlw"
End:
*)
